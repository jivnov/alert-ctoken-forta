"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransactionEvent = exports.createBlockEvent = exports.formatAddress = exports.keccak256 = exports.assertShellResult = exports.assertIsNonEmptyString = exports.assertExists = exports.getJsonFile = void 0;
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var lodash_1 = __importDefault(require("lodash"));
var jsonc_1 = require("jsonc");
var sha3_1 = require("sha3");
var sdk_1 = require("../../sdk");
var getJsonFile = function (filePath) {
    if (filePath.startsWith("." + path_1.default.sep)) {
        filePath = filePath.replace("." + path_1.default.sep, "" + process.cwd() + path_1.default.sep);
    }
    var data = fs_1.default.readFileSync(filePath, 'utf8');
    return jsonc_1.jsonc.parse(data);
};
exports.getJsonFile = getJsonFile;
var assertExists = function (obj, objName) {
    if (lodash_1.default.isNil(obj))
        throw new Error(objName + " is required");
};
exports.assertExists = assertExists;
var assertIsNonEmptyString = function (str, varName) {
    if (!lodash_1.default.isString(str) || str.length === 0) {
        throw new Error(varName + " must be non-empty string");
    }
};
exports.assertIsNonEmptyString = assertIsNonEmptyString;
var assertShellResult = function (result, errMsg) {
    if (result.code !== 0) {
        throw new Error(errMsg + ": " + result.stderr);
    }
};
exports.assertShellResult = assertShellResult;
var keccak256 = function (str) {
    var hash = new sha3_1.Keccak(256);
    hash.update(str);
    return "0x" + hash.digest('hex');
};
exports.keccak256 = keccak256;
var formatAddress = function (address) {
    return lodash_1.default.isString(address) ? address.toLowerCase() : address;
};
exports.formatAddress = formatAddress;
var createBlockEvent = function (block, networkId) {
    var blok = {
        difficulty: block.difficulty.toString(),
        extraData: block.extraData,
        gasLimit: block.gasLimit.toString(),
        gasUsed: block.gasUsed.toString(),
        hash: block.hash,
        logsBloom: block.logsBloom,
        miner: exports.formatAddress(block.miner),
        mixHash: block.mixHash,
        nonce: block.nonce,
        number: block.number,
        parentHash: block.parentHash,
        receiptsRoot: block.receiptsRoot,
        sha3Uncles: block.sha3Uncles,
        size: block.size.toString(),
        stateRoot: block.stateRoot,
        timestamp: typeof block.timestamp === 'string' ? parseInt(block.timestamp) : block.timestamp,
        totalDifficulty: block.totalDifficulty.toString(),
        transactions: block.transactions.map(function (tx) { return tx.hash; }),
        transactionsRoot: block.transactionsRoot,
        uncles: block.uncles
    };
    return new sdk_1.BlockEvent(sdk_1.EventType.BLOCK, networkId, blok);
};
exports.createBlockEvent = createBlockEvent;
var createTransactionEvent = function (receipt, block, networkId, traces) {
    var _a;
    var _b;
    if (traces === void 0) { traces = []; }
    var transaction = block.transactions.find(function (tx) { return tx.hash === receipt.transactionHash; });
    var tx = {
        hash: transaction.hash,
        from: exports.formatAddress(transaction.from),
        to: transaction.to ? exports.formatAddress(transaction.to) : null,
        nonce: transaction.nonce,
        gas: transaction.gas.toString(),
        gasPrice: transaction.gasPrice,
        value: transaction.value,
        data: transaction.input,
        r: transaction.r,
        s: transaction.s,
        v: transaction.v,
    };
    var addresses = (_a = {},
        _a[tx.from] = true,
        _a);
    if (tx.to) {
        addresses[tx.to] = true;
    }
    var rcpt = {
        blockNumber: receipt.blockNumber,
        blockHash: receipt.blockHash,
        transactionIndex: receipt.transactionIndex,
        transactionHash: receipt.transactionHash,
        status: receipt.status,
        logsBloom: receipt.logsBloom,
        contractAddress: receipt.contractAddress ? exports.formatAddress(receipt.contractAddress) : null,
        gasUsed: receipt.gasUsed.toString(),
        cumulativeGasUsed: receipt.cumulativeGasUsed.toString(),
        logs: receipt.logs.map(function (log) { return ({
            address: exports.formatAddress(log.address),
            topics: log.topics,
            data: log.data,
            logIndex: log.logIndex,
            blockNumber: log.blockNumber,
            blockHash: log.blockHash,
            transactionIndex: log.transactionIndex,
            transactionHash: log.transactionHash,
            removed: false,
        }); }),
        root: (_b = receipt.root) !== null && _b !== void 0 ? _b : '',
    };
    rcpt.logs.forEach(function (log) { return addresses[log.address] = true; });
    var blok = {
        hash: block.hash,
        number: block.number,
        timestamp: typeof block.timestamp === 'string' ? parseInt(block.timestamp) : block.timestamp
    };
    var trcs = [];
    traces.forEach(function (trace) {
        var _a, _b, _c, _d;
        addresses[exports.formatAddress(trace.action.address)] = true;
        addresses[exports.formatAddress(trace.action.refundAddress)] = true;
        addresses[exports.formatAddress(trace.action.to)] = true;
        addresses[exports.formatAddress(trace.action.from)] = true;
        trcs.push({
            action: {
                callType: trace.action.callType,
                to: exports.formatAddress(trace.action.to),
                input: trace.action.input,
                from: exports.formatAddress(trace.action.from),
                value: trace.action.value,
                init: trace.action.init,
                address: exports.formatAddress(trace.action.address),
                balance: trace.action.balance,
                refundAddress: exports.formatAddress(trace.action.refundAddress),
            },
            blockHash: trace.blockHash,
            blockNumber: trace.blockNumber,
            result: {
                gasUsed: (_a = trace.result) === null || _a === void 0 ? void 0 : _a.gasUsed,
                address: (_b = trace.result) === null || _b === void 0 ? void 0 : _b.address,
                code: (_c = trace.result) === null || _c === void 0 ? void 0 : _c.code,
                output: (_d = trace.result) === null || _d === void 0 ? void 0 : _d.output
            },
            subtraces: trace.subtraces,
            traceAddress: trace.traceAddress,
            transactionHash: trace.transactionHash,
            transactionPosition: trace.transactionPosition,
            type: trace.type,
            error: trace.error,
        });
    });
    return new sdk_1.TransactionEvent(sdk_1.EventType.BLOCK, networkId, tx, rcpt, trcs, addresses, blok);
};
exports.createTransactionEvent = createTransactionEvent;
